---

title: Forecast


keywords: fastai
sidebar: home_sidebar

summary: "This module contains the forecast algorithm for a DGLM. Given predictors, these functions return a random sample from the forecast distribution. Using this sample, you can calculate point estimates (means, medians), and measures of uncertainty such as credible intervals. For any model `mod`, the correct method usage is `mod.forecast_marginal(k, X)` and `mod.forecast_path(k, X)`, so they do not need to be called separately from the model."
description: "This module contains the forecast algorithm for a DGLM. Given predictors, these functions return a random sample from the forecast distribution. Using this sample, you can calculate point estimates (means, medians), and measures of uncertainty such as credible intervals. For any model `mod`, the correct method usage is `mod.forecast_marginal(k, X)` and `mod.forecast_path(k, X)`, so they do not need to be called separately from the model."
nb_path: "nbs/02_forecast.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02_forecast.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Marginal-Forecasting">Marginal Forecasting<a class="anchor-link" href="#Marginal-Forecasting"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_marginal" class="doc_header"><code>forecast_marginal</code><a href="https://github.com/lavinei/pybats_nbdev/tree/master/pybats_nbdev/forecast.py#L39" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_marginal</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>mean_only</code></strong>=<em><code>False</code></em>, <strong><code>state_mean_var</code></strong>=<em><code>False</code></em>, <strong><code>y</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Marginal forecast function k steps ahead</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This forecast method works for Poisson and Bernoulli DGLMs. Below are very simple tests:</p>
<ul>
<li>Manually define a simple DGLM with an intercept and 2 regression predictors</li>
<li>Define new $X_t$</li>
<li>Forecast by drawing a random sample at $k=5$, and getting a $95\%$ credible interval</li>
<li>Forecast the mean only using a special flag, to test the function</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pybats_nbdev.dglm</span> <span class="kn">import</span> <span class="n">dlm</span><span class="p">,</span> <span class="n">pois_dglm</span><span class="p">,</span> <span class="n">bern_dglm</span><span class="p">,</span> <span class="n">bin_dglm</span>
<span class="kn">from</span> <span class="nn">pybats_nbdev.analysis</span> <span class="kn">import</span> <span class="n">analysis</span>

<span class="c1"># Define Poisson and Bernoulli DGLMs, along with a normal DLM, with 1 trend term and 2 regression predictors</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">R0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">mod_n</span> <span class="o">=</span> <span class="n">dlm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">,</span> <span class="n">discount_forecast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mod_p</span> <span class="o">=</span> <span class="n">pois_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>
<span class="n">mod_bern</span> <span class="o">=</span> <span class="n">bern_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>

<span class="c1"># New predictors for k=5 steps into the future</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First we're going to forecast from the Poisson DGLM, which will draw a random sample from the forecast distribution. We'll use the forecast samples to calculate a $95\%$ credible interval.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">forecast_samples</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Get the 95% credible intervals</span>
<span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">forecast_samples</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([   0. , 1317.2])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can repeat this analysis using the normal DLM:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">forecast_samples</span> <span class="o">=</span> <span class="n">mod_n</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Get the 95% credible intervals</span>
<span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">forecast_samples</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([-41.2778695 ,  39.14389697])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next we'll test the models using the special flag <code>mean_only=True</code>. This will return only the mean value, without simulation from the forecast distribution. It is much faster if the mean is the only value of interest.</p>
<p>Notice that we skipped simulating from the Bernoulli DGLM, because Bernoulli outcomes are only $0$ or $1$ anyway. The mean of the forecast distribution in a Bernoulli DGLM is equal to the probability of the outcome being $1$.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Setting the flag mean_only=True returns the exact mean, without simulation</span>

<span class="n">m_p</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">232.15794803433968</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_p</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># Test the Bernoulli DGLM forecast mean is correct</span>
<span class="c1"># Setting the flag mean_only=True returns the exact mean, without simulation</span>

<span class="n">m_bern</span> <span class="o">=</span> <span class="n">mod_bern</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.9344642829948064</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_bern</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># Test the Bernoulli DGLM forecast mean is correct</span>
<span class="c1"># Setting the flag state_mean_var=True returns the exact mean and variance, without simulation</span>

<span class="n">m_n</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">mod_n</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">state_mean_var</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">9.222222222</span><span class="p">]</span>
<span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_n</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, <code>mod.forecast_marginal</code> has three special features beyond returning just a random sample from the forecast distribution:</p>
<ol>
<li>Setting <code>mean_only = True</code> makes the function return the mean of the forecast distribution, instead of a random sample.</li>
<li>Setting <code>state_mean_and_var = True</code> makes the function return the mean and variance of the linear predictor, $\lambda_t = F_t^{'} \theta_t$.</li>
<li>Passing in a value for <code>y</code> makes the function return the <em>log</em> probability density of <code>y</code> under the forecast distribution, $p(y)$.</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_marginal_bindglm" class="doc_header"><code>forecast_marginal_bindglm</code><a href="https://github.com/lavinei/pybats_nbdev/tree/master/pybats_nbdev/forecast.py#L68" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_marginal_bindglm</code>(<strong><code>mod</code></strong>, <strong><code>n</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>mean_only</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Marginal forecast function k steps ahead for a binomial DGLM</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we'll repeat the same tests from above on a binomial DGLM by specifying both the predictors <code>X</code> and the number of trials <code>n</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mod_b</span> <span class="o">=</span> <span class="n">bin_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>

<span class="c1"># Test the Binomial DGLM</span>
<span class="n">m_bin</span> <span class="o">=</span> <span class="n">mod_b</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">9.34464283</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_bin</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Path-forecasting">Path forecasting<a class="anchor-link" href="#Path-forecasting"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_path" class="doc_header"><code>forecast_path</code><a href="https://github.com/lavinei/pybats_nbdev/tree/master/pybats_nbdev/forecast.py#L113" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_path</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>)</p>
</blockquote>
<p>Path forecast function k steps ahead using sequential simulation</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_path_copula" class="doc_header"><code>forecast_path_copula</code><a href="https://github.com/lavinei/pybats_nbdev/tree/master/pybats_nbdev/forecast.py#L165" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_path_copula</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>t_dist</code></strong>=<em><code>False</code></em>, <strong><code>y</code></strong>=<em><code>None</code></em>, <strong><code>nu</code></strong>=<em><code>9</code></em>, <strong><code>return_cov</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Path forecast function k steps ahead using a copula model</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_path_dlm" class="doc_header"><code>forecast_path_dlm</code><a href="https://github.com/lavinei/pybats_nbdev/tree/master/pybats_nbdev/forecast.py#L214" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_path_dlm</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>approx</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Path forecast function k steps ahead for a DLM</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There are two functions for path forecasting with DGLMs. <a href="/pybats_nbdev/forecast.html#forecast_path_copula"><code>forecast_path_copula</code></a> is the default method, and is part of my new <a href="https://arxiv.org/pdf/2007.04956.pdf">research</a>. It dramatically speeds up path forecasting in DGLMs. The traditional <a href="/pybats_nbdev/forecast.html#forecast_path"><code>forecast_path</code></a> function is only used when <code>mod.forecast_path</code> is called with the flag <code>copula=FALSE</code>.</p>
<p>Below we'll test path forecasting - with a copula, as is the default - for $k=2$ steps into the future. The Poisson model will have $2$ trend terms - an intercept and a slope - and 1 regression term. This test will confirm that marginal forecasting and path forecasting lead to identical forecast means for $k=1$ and $k=2$ steps ahead.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">R0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span>
<span class="n">mod_p</span> <span class="o">=</span> <span class="n">pois_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>

<span class="c1"># The predictors for the next 2 time steps, X_t and X_(t+1), in a matrix with k=2 rows</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]])</span>

<span class="c1"># Test the Poisson DGLM by comparing the path and marginal forecast distributions</span>
<span class="n">samps_copula</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_path_copula</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">m_samp</span> <span class="o">=</span> <span class="n">samps_copula</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">m_marg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
          <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_samp</span> <span class="o">-</span> <span class="n">m_marg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="n">samps_path</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_path</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">m_samp</span> <span class="o">=</span> <span class="n">samps_path</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_samp</span> <span class="o">-</span> <span class="n">m_marg</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, <code>mod.forecast_path</code> has two special features beyond returning just a random sample from the forecast distribution. These only work when using <a href="/pybats_nbdev/forecast.html#forecast_path_copula"><code>forecast_path_copula</code></a>, which is not called for a normal DLM.</p>
<ol>
<li>Passing in a value (a vector of length $k$) for <code>y</code> makes the function return the <em>log</em> probability density of <code>y</code> under the forecast distribution, $p(y)$.</li>
<li>Setting <code>return_cov = True</code> makes the function return the covariance in the copula distribution. This is slightly different than the covariance in the forecast distribution, which can be calculated directly from a random sample.</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Multivariate-forecasting-with-a-copula-(Recoupling)">Multivariate forecasting with a copula (Recoupling)<a class="anchor-link" href="#Multivariate-forecasting-with-a-copula-(Recoupling)"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_joint_copula_sim" class="doc_header"><code>forecast_joint_copula_sim</code><a href="https://github.com/lavinei/pybats_nbdev/tree/master/pybats_nbdev/forecast.py#L374" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_joint_copula_sim</code>(<strong><code>mod_list</code></strong>, <strong><code>lambda_mu</code></strong>, <strong><code>lambda_cov</code></strong>, <strong><code>nsamps</code></strong>, <strong><code>t_dist</code></strong>=<em><code>False</code></em>, <strong><code>nu</code></strong>=<em><code>9</code></em>)</p>
</blockquote>
<p>Jointly forecast from multiple DGLMs which share a latent factor</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This function is used to jointly forecast from separately DGLMs which share a common latent factor. The uncertainty in the forecast of the latent factor induces dependence among the models. Just as with path forecasting, the dependence is important when calculating joint functions of the model forecasts. The most common example is forecasting the <em>sum</em> across models, $\sum_{i=1:m} y_{i,t}$.</p>
<p><strong>COME BACK TO THIS, SEE IF IT SHOULD BE HIDDEN WHEN I DO THE LATENT FACTOR DOCUMENTATION</strong></p>

</div>
</div>
</div>
</div>
 

